(* 
  This code is taken directly from the Rescript project
  https://github.com/rescript-lang/syntax

  Original license reproduced below:

  MIT License

  Copyright (c) 2020 ReScript

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


*)

type t

val nil: t
val line: t
val hardLine: t
val softLine: t
val literalLine: t
val text: string -> t
val concat: t list -> t
val indent: t -> t
val ifBreaks: t -> t -> t
val lineSuffix: t -> t
val group: t -> t
val breakableGroup: forceBreak : bool -> t -> t
(* `customLayout docs` will pick the layout that fits from `docs`.
 * This is a very expensive computation as every layout from the list
 * will be checked until one fits. *)
val customLayout: t list -> t
val breakParent: t
val join: sep: t -> t list -> t

val space: t
val comma: t
val dot: t
val dotdot: t
val dotdotdot: t
val lessThan: t
val greaterThan: t
val lbrace: t
val rbrace: t
val lparen: t
val rparen: t
val lbracket: t
val rbracket: t
val question: t
val tilde: t
val equal: t
val trailingComma: t
val doubleQuote: t [@@live]

(*
 * `willBreak doc` checks whether `doc` contains forced line breaks.
 * This is more or less a "workaround" to make the parent of a `customLayout` break.
 * Forced breaks are not propagated through `customLayout`; otherwise we would always
 * get the last layout the algorithm triesâ€¦
 * This might result into some weird layouts:
 *  [fn(x => {
 *     let _ = x
 *   }), fn(y => {
 *     let _ = y
 *   }), fn(z => {
 *     let _ = z
 *   })]
 *  The `[` and `]` would be a lot better broken out.
 *  Although the layout of `fn(x => {...})` is correct, we need to break its parent (the array).
 *  `willBreak` can be used in this scenario to check if the `fnâ€¦` contains any forced breaks.
 *  The consumer can then manually insert a `breakParent` doc, to manually propagate the
 *  force breaks from bottom to top.
 *)
val willBreak: t -> bool

val toString: width: int -> t -> string
val debug: t -> unit [@@live]