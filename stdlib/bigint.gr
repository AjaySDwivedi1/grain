import Memory from "runtime/unsafe/memory"
import Tags from "runtime/unsafe/tags"
import WasmI32 from "runtime/unsafe/wasmi32"
import Exception from "runtime/exception"
import { coerceNumberToWasmI32 } from "runtime/numbers"
import Conv from "runtime/unsafe/conv"
import Int32 from "int32"
import Buffer from "buffer"
import String from "string"

// Layout:
// -------------------------
// | tag | size | limbs... |
// -------------------------
// 
// tag   | i32    | always _GRAIN_BIGINT_BOXED_NUM_TAG
// size  | i32    | the number of limbs. If negative, the bigint is negative
// limbs | i64... | 

// TODO: use faster abs algos
// https://stackoverflow.com/questions/664852/which-is-the-fastest-way-to-get-the-absolute-value-of-a-number

@disableGC
let absi32 = (n) => {
  let (<) = WasmI32.lt
  if (n < 0n) { -n } else { n }
}

@disableGC
let absi64 = (n) => {
  let (<) = WasmI64.lt
  if (n < 0N) { -n } else { n }
}

@disableGC
let init = (limbs: WasmI32) => {
  let (+) = WasmI32.add
  let (*) = WasmI32.mul
  let (<) = WasmI32.lt
  
  if (limbs == 0n) {
    throw Exception.InvalidArgument("BigInt must have at least 1 limb")
  }
  
  let tagLen = 4n
  let sizeLen = 4n
  let limbsLen = absi32(limbs) * 8n
  let len = tagSize + sizeSize + limbsSize

  let ptr = Memory.malloc(len)
  Memory.fill(ptr, 0n, len)
  
  WasmI32.store(ptr, Tags._GRAIN_BIGINT_BOXED_NUM_TAG, 0n)
  WasmI32.store(ptr, limbs, 4n)
  
  ptr
}

@disableGC
let getSize = (ptr) => {
  let (<) = WasmI32.lt
  let (*) = WasmI32.mul
  WasmI32.load(ptr, 4n)
}

@disableGC
let setSize = (ptr, n) => {
  let (<) = WasmI32.lt
  let (*) = WasmI32.mul
  WasmI32.store(ptr, n, 4n)
}

@disableGC
let getLimb = (ptr, i) => {
  let (+) = WasmI32.add
  let (*) = WasmI32.mul
  WasmI64.load(ptr, 8n + (8n * i))
}

@disableGC
let setLimb = (ptr, i, v) => {
  let (+) = WasmI32.add
  let (*) = WasmI32.mul
  WasmI64.store(ptr, v, 8n + (8n * i))
}

@disableGC
export let rec fromInt32 = (n: Int32) => {
  let (*) = WasmI32.mul
  let (<) = WasmI32.lt
  let v = Conv.fromInt32(n)
  let limbs = if (v < 0n) { -1n } else { 1n }
  let ptr = init(limbs)
  setLimb(ptr, 0n, WasmI64.extendI32U(v))
  WasmI32.toGrain(ptr): BigInt
}

@disableGC
export let rec fromInt64 = (n: Int64) => {
  let (<) = WasmI64.lt
  let (*) = WasmI64.mul
  let v = Conv.fromInt64(n)
  let sign = if (v < 0N) { -1n } else { 1n }
  let ptr = init(limbs)
  setLimb(ptr, 0n, v)
  WasmI32.toGrain(ptr): BigInt
}

@disableGC
let addN = (rp: WasmI32, a: WasmI32, b: WasmI32, n: WasmI32) => {
  let (+) = WasmI64.add
  let (<) = WasmI64.lt
  let (*) = WasmI64.mul
  let mut cy = 0N;
  for (let mut i = 0n; WasmI32.lt(i, n); i = WasmI32.add(i, 1n)) {
    let mut a = getLimb(a, i)
    let mut b = getLimb(b, i)
    let mut r = a + cy
    cy = if (r < cy) { 1N } else { 0N }
    r += b
    cy += if (r < b) { 1N } else { 0N }
    setLimb(rp, i, r)
  }
  cy
}

@disableGC
let add1 = (rp: WasmI32, a: WasmI32, n: WasmI32, b: WasmI64) => {
  let (+) = WasmI64.add
  let (<) = WasmI64.lt
  let mut b_ = b;
  for (let mut i = 0n; WasmI32.lt(i, n); i = WasmI32.add(i, 1n)) {
    let r = getLimb(a, i) + b
    b_ = if (r < b_) { 1N } else { 0N }
    setLimb(rp, i, r)
  }
  b_
}

@disableGC
let absAdd = (a: WasmI32, b: WasmI32) => {
  let (>) = WasmI32.gt
  let (>=) = WasmI32.gte
  let (+) = WasmI32.add
  let (-) = WasmI32.sub

  let an = absi32(getSize(a))
  let bn = absi32(getSize(b))
  
  let min = if (an > bn) { bn } else { an }
  let limbsLen = min + 1n
  let r = init(limbsLen)
  let rp = r + 8n

  let cy = if (an >= bn) {
    let mut cy = addN(rp, a, b, bn)
    if (an > bn) {
      cy = add1(rp + bn, a, a + bn, an - bn, cy)
    }
    cy
  } else {
    addN(rp, b, a, an)
  }

  setLimb(rp, an, cy)

  let rn = an + WasmI32.wrapI64(cy)
  if (0n > an) {
    setSize(r, -rn)
  } else {
    setSize(r, rn)
  };

  WasmI32.toGrain(ptr): BigInt
}

@disableGC
let rec add = (a: BigInt, b: BigInt) => {
  let (^) = WasmI32.xor
  let (>=) = WasmI32.gte
  let aptr = WasmI32.fromGrain(a)
  let bptr = WasmI32.fromGrain(b)
  let an = WasmI32.load(aptr, 4n)
  let bn = WasmI32.load(bptr, 4n)
  if ((an ^ bn) >= 0n) {
    absAdd(aptr, bptr)
  } else {
    throw Exception.AssertionError("unimplemented")
  }
}

// @disableGC
// let subIntoBufferN = (rp: Buffer, a: WasmI32, b: WasmI32, n: WasmI32) => {
//   let (-) = WasmI64.sub
//   let (+) = WasmI64.add
//   let (<) = WasmI64.lt
//   let mut cy = 0N;
//   for (let mut i = 0n; WasmI32.lt(i, n); i = WasmI32.add(i, 1n)) {
//     let mut a = safeGetLimb(a, i)
//     let mut b = safeGetLimb(b, i)
//     b += cy
//     cy = if (b < cy) { 1N } else { 0N }
//     cy += if (a < b) { 1N } else { 0N }
//     Buffer.addInt64(rp, a - b)
//   }
//   cy
// }

// @disableGC
// let cmpN = (a, b, n) => {
//   let mut res = 0n;
//   while (--n >= 0) {
//     let x = safeGetLimb(a, n)
//     let y = safeGetLimb(b, n)
//     if (x != y) {
//       res = if (x > y) { 1n } else { -1n }
//       break
//     }
//   }
//   res
// }

// @disableGC
// let absSub = (a: WasmI32, b: WasmI32) => {
//   let (<) = WasmI32.lt
//   let (*) = 
//   let an = absi32(getSize(a))
//   let bn = absi32(getSize(b))

//   let len = if (an < bn) { bn } else { an }
//   let cmp = cmpN(a, b, len)

//   let rp = Buffer.make(8) // 1 int64

//   let limbs = if (cmp > 0n) {
//     subIntoBufferN(rp, a, b, bn)
//   } else if (cmp < 0n) {
//     -1N * subIntoBufferN(rp, a, b, an)
//   } else {
//     1N
//   }
  
//   let sign = if (WasmI64.lt(limbs, 0N) { -1n } else { 1n };
//   let src = init(sign, limbs)
//   let dst = WasmI32.fromGrain(rp.data)
//   let len = WasmI32.fromGrain(dst, 4n)
//   Memory.copy(src + 8n, dst + 8n, len)
  
//   WasmI32.toGrain(ptr): BigInt
// }

// @disableGC
// let rec sub = (a: BigInt, b: BigInt) => {
//   let (^) = WasmI32.xor
//   let (>=) = WasmI32.gte
//   let aptr = WasmI32.fromGrain(a)
//   let bptr = WasmI32.fromGrain(b)
//   let an = WasmI32.load(aptr, 4n)
//   let bn = WasmI32.load(bptr, 4n)
//   if ((an ^ bn) >= 0n) {
//     absSub(aptr, bptr)
//   } else {
//     absAdd(aptr, bptr)
//   }
// }


// @disableGC
// export let rec fromString = (str: String) => {
//   let s = String.trim(str)
//   Memory.decRef(WasmI32.fromGrain(str))
  
//   let stringLen = String.length(s)
  
//   // empty string
//   if (stringLen == 0) {
//     throw Exception.InvalidArgument("The given string is not a valid number")
//   }

//   // get the sign
//   let mut isNegative = String.charAt(0) == '-'
  
//   // bad negative number (only leading '-')
//   if (isNegative && stringLen == 1) {
//     throw Exception.InvalidArgument("The given string is not a valid number")
//   }

//   Memory.decRef(WasmI32.fromGrain(stringLen))

//   // Parse the string!!!!!!
//   throw Exception.AssertionError("fromString unimplemented")

//   let size = 0n;
//   Memory.decRef(WasmI32.fromGrain(s))
//   let bigint = alloc(coerceNumberToWasmI32(size))
//   let ret = WasmI32.toGrain(bigint): BigInt
//   Memory.decRef(WasmI32.fromGrain(make))
//   ret
// }
